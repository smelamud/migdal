#!/usr/bin/perl

# @(#) $Id$

$Line='';
$LineN=1;
$Eof=0;
$Token='';

%Quotes=('<!--' => 'Comment',
         '<?'   => 'PHP',
	 '<<'   => 'Remark',
         '<'    => 'Tag',
	 ''     => 'Text');
@GetPrefixes=('get','is','has','mandatory');

@Requests=();
$Header='';
$Body='';
$Footer='';

$AfterRedirect=0;
$BodyToHeader=0;
$Retarget='';

$ElementName='';
$ElementBody='';
@ElementGlobals=();

$LastIter='';
$LastItem='';
$LastResult='';
$LastConst='';

$Stack='';

%Macros=();
%Elements=();

#### Utility functions ####

sub constructRemake
{
my ($s,$after)=@_;
my $redir='';

@del=();
@subs=();
%params=();
request('lib/uri.php');
if($after || $AfterRedirect && !$BodyToHeader)
  {
  getGlobal('redir');
  $redir='$redir->getURI()';
  }
else
  {
  getGlobal('REQUEST_URI');
  $redir='$REQUEST_URI';
  }
splitParams($s,\%params);
while(my($name,$value)=each(%params))
     {
     if($value eq '')
       {
       push @del,"'$name'";
       }
     else
       {
       push @subs,"'$name' => ".subTypedValue('','%',$value);
       }
     }
return "remakeURI($redir,array(".join(',',@del).'),array('.join(',',@subs).'))';
}

sub getGetName
{
my ($name)=@_;

foreach(@GetPrefixes)
       {
       return $name if lc(substr($name,0,length $_)) eq $_;
       }
return "get$name";
}

sub getGlobal
{
my ($name)=@_;

push @ElementGlobals,$name if $ElementName ne '' and
                              !grep {$_ eq $name} @ElementGlobals;
return $name;
}

sub subVar
{
my ($s,$st,$ed)=@_;

my $item=$Stack->top()->getItem();
my $iter=$Stack->top()->getIterator();
my $result=$Stack->top()->getResult();
my $const=$Stack->top()->getConst();

if($s=~/^(.*)@([ERJ]?\w)$/)
  {
  request('lib/calendar.php');
  return "${st}formatAnyDate('$2',".subVar($1).")$ed";
  }
request('lib/utils.php') if $s=~/^\$\$?\^/;
return $st.constructRemake($1,0).$ed
       if $s=~/^\$\[([^\]]*)\]$/;
return $st.constructRemake($1,1).$ed
       if $s=~/^\$\$\[([^\]]*)\]$/;
return "${st}urlencode(".constructRemake($1,0).")$ed"
       if $s=~/^\$#\[([^\]]*)\]$/;
return "$st$1$ed"
       if $s=~/^\*{?(\w+)}?$/;
return "$st\$".getGlobal('redir')."->getId()$ed"
       if $s=~/^\$_$/;
return "$st\$".getGlobal('REQUEST_URI').$ed
       if $s=~/^\$-$/;
return "${st}urlencode(\$".getGlobal('REQUEST_URI').")$ed"
       if $s=~/^\$#-$/;
return "$st\$".getGlobal('lastRedir')."->getURI()$ed"
       if $s=~/^\$--$/;
return "${st}urlencode(\$".getGlobal('lastRedir')."->getURI())$ed"
       if $s=~/^\$#--$/;
return "$st\$".getGlobal('REQUEST_URI').$ed
       if $s=~/^\$-$/;
return "${st}urlencode(\$".getGlobal('REQUEST_URI').")$ed"
       if $s=~/^\$#-$/;
return "$st\$".getGlobal('SCRIPT_NAME').$ed
       if $s=~/^\$~$/;
return "$st\$".getGlobal('QUERY_STRING').$ed
       if $s=~/^\$\?$/;
return "${st}urlencode(\$".getGlobal('QUERY_STRING').")$ed"
       if $s=~/^\$#\?$/;
return "$st\$$item$ed"
       if $s=~/^\$\.$/;
return "${st}uc(\$$item)$ed"
       if $s=~/^\$\^\.$/;
return "$st\$$result$ed"
       if $s=~/^\$,$/;
return "${st}uc(\$$result)$ed"
       if $s=~/^\$\^,$/;
return "$st\$$iter$ed"
       if $s=~/^\$;$/;
return "$st\$$const$ed"
       if $s=~/^\$\*$/;
return "$st\$$1$ed"
       if $s=~/^\${?(\w+)}?$/;
return "${st}uc(\$$1)$ed"
       if $s=~/^\$\^{?(\w+)}?$/;
return "$st\$".getGlobal($1).$ed
       if $s=~/^\$\${?(\w+)}?$/;
return "${st}uc(\$".getGlobal($1).")$ed"
       if $s=~/^\$\$\^{?(\w+)}?$/;
return "${st}urlencode(\$$1)$ed"
       if $s=~/^\$#{?(\w+)}?$/;
return "${st}urlencode(\$".getGlobal($1).")$ed"
       if $s=~/^\$\$#{?(\w+)}?$/;
return "$st\$$item->".getGetName($1)."()$ed"
       if $s=~/^\${?\.(\w+)}?$/;
return "$st\$$result->".getGetName($1)."()$ed"
       if $s=~/^\${?,(\w+)}?$/;
return "$st\$$iter->".getGetName($1)."()$ed"
       if $s=~/^\${?;(\w+)}?$/;
return "$st\$$1->".getGetName($2)."()$ed"
       if $s=~/^\${?(\w+)[\.,;](\w+)}?$/;
return "$st\$".getGlobal($1).'->'.getGetName($2)."()$ed"
       if $s=~/^\$\${?(\w+)[\.,;](\w+)}?$/;
return "${st}uc(\$$item->".getGetName($1)."())$ed"
       if $s=~/^\$\^{?\.(\w+)}?$/;
return "${st}uc(\$$result->".getGetName($1)."())$ed"
       if $s=~/^\$\^{?,(\w+)}?$/;
return "${st}uc(\$$iter->".getGetName($1)."())$ed"
       if $s=~/^\$\^{?;(\w+)}?$/;
return "${st}uc(\$$1->".getGetName($2)."())$ed"
       if $s=~/^\$\^{?(\w+)[\.,;](\w+)}?$/;
return "${st}uc(\$".getGlobal($1).'->'.getGetName($2)."())$ed"
       if $s=~/^\$\$\^{?(\w+)[\.,;](\w+)}?$/;
return "${st}urlencode(\$$item->".getGetName($1)."())$ed"
       if $s=~/^\$#{?\.(\w+)}?$/;
return "${st}urlencode(\$$result->".getGetName($1)."())$ed"
       if $s=~/^\$#{?,(\w+)}?$/;
return "${st}urlencode(\$$iter->".getGetName($1)."())$ed"
       if $s=~/^\$#{?;(\w+)}?$/;
return "${st}urlencode(\$$1->".getGetName($2)."())$ed"
       if $s=~/^\$#{?(\w+)[\.,;](\w+)}?$/;
return "${st}urlencode(\$".getGlobal($1).'->'.getGetName($2)."())$ed"
       if $s=~/^\$\$#{?(\w+)[\.,;](\w+)}?$/;
return "'$st$s$ed'";
}

sub subVars
{
my ($s,$st,$ed)=@_;
my $c='';

while($s ne '')
     {
     my $head,$var;
     ($head,$var,$s)=$s=~m/
                           ^([^\$\*]*)
			   (
			    (?:
			     (?:
			      (?:
			       \$\$?[\#\^]?
			       (?:
				(?: {? \w* [\.,;]? \w+ }? )
				|
				(?: \[[^\]]*\] )
				|
				(?: [_\.,;\~\*\-\?]+ )
			       )
			      )
			      |
			      (?: \*{?\w+}? )
			     )
			     (?: @[ERJ]?\w )?
			    )?
			   )
			   (.*)$
			  /sx;
     $c.=$head;
     $c.=subVar($var,$st,$ed) if $var ne '';
     if($head eq '' && $var eq '')
       {
       $c.=substr($s,0,1);
       substr($s,0,1)='';
       }
     }
return $c;
}

sub subVarsText
{
my ($s)=@_;

return subVars($s,'<?php echo ','; ?>');
}

sub subConcat
{
my ($s)=@_;

my $value="'".subVars($s,"'.",".'")."'";
$value=~s/^''\.//;
$value=~s/\.''$//;
return $value;
}

sub subTypedValue
{
my ($type,$default,$s)=@_;

$type=$type eq '' ? $default : $type;
return $s if $type eq '$';
return subVar($s) if $type eq '%';
return subVars($s) if $type eq '!';
return subConcat($s) if $type eq '#';
}

sub getArgList
{
my ($s)=@_;

my $ss='';
my $i=1;
foreach(map{s/^\$//;$_} split(/[\s,]+/,$s))
       {
       $ss.="arg$i\%!$_='\%$_' ";
       $i++;
       }
return $ss;
}

sub subMacroParam
{
my ($s,$params,$types)=@_;

return $params->{$1}
       if $s=~/^%{?(\w+)}?$/;
return uc($params->{$1})
       if $s=~/^%\^{?(\w+)}?$/;
return $types->{$1}
       if $s=~/^%!{?(\w+)}?$/;
return getArgList($params->{$1})
       if $s=~/^%\@{?(\w+)}?$/;
return $s;
}

sub subMacroParams
{
my ($s,$params,$types)=@_;
my $c='';

while($s ne '')
     {
     my $head,$var;
     ($head,$var,$s)=$s=~/^([^%]*)((?:%[\^@!]?{?\w+}?)?)(.*)$/s;
     $c.=$head;
     $c.=subMacroParam($var,$params,$types) if $var ne '';
     }
return $c;
}

sub splitParams
{
my ($token,$args,$types)=@_;

while($token!~/^\s*$/)
     {
     my $name,$value;
     ($name,$type,$value,$token)=$token=~m/
					   ^\s*(\w+)([\$#%!]?)\s*
					   (?:
					    =\s*
					    (
					     (?: [^\s'"]+ )
					     |
					     (?: '[^']*' )
					     |
					     (?: "[^"]*" )
					    )
					   )?
					   (.*)$
					  /sx;
     $value=substr $value,1,-1 if $value=~/^['"]/;
     $args->{lc $name}=$value;
     $types->{lc $name}=$type if defined($types);
     }
}

sub constructParams
{
my ($args,$types)=@_;

my @params=();
for(my $n=1;exists $args->{"arg$n"};$n++)
   {
   push @params,subTypedValue($types->{"arg$n"},'%',$args->{"arg$n"});
   }
return join ',',@params;
}

sub getElementFuncName
{
my ($s)=@_;

$s=~tr{/}{_};
return "display$s";
}

#### Macro ####

package Macro;

sub new
{
my ($class,$body,$defaults)=@_;

my $self=bless {'body' => $body},$class;
$self->{'defaults'}={};
::splitParams($defaults,$self->{'defaults'});
return $self;
}

sub getBody
{
my ($self)=@_;

return $self->{'body'};
}

sub getInstance
{
my ($self,$params,$types)=@_;

my %args=();
while(my($name,$value)=each(%{$self->{'defaults'}}))
     {
     $args{$name}=$value;
     }
while(my($name,$value)=each(%{$params}))
     {
     $args{$name}=$value if $value ne '';
     }
my $s=::subMacroParams($self->getBody(),\%args,$types);
return $s;
}

#### Element ####

package Element;

sub new
{
my ($class,$file,$params,$defaults)=@_;

my $self=bless {'file' => $file},$class;
$params=~s/^\s+//;
$params=~s/\s+$//;
$self->{'params'}=[];
@{$self->{'params'}}=map{s/^\$//;$_} split(/[\s,]+/,$params);
$self->{'defaults'}={};
::splitParams($defaults,$self->{'defaults'});
return $self;
}

sub getFile
{
my ($self)=@_;

return $self->{'file'};
}

sub getParams
{
my ($self,$args,$types)=@_;

my @list=();
foreach(@{$self->{'params'}})
       {
       push @list,::subTypedValue($types->{$_},'%',
                    exists $args->{$_} && $args->{$_} ne ''
                    ? $args->{$_} : $self->{'defaults'}->{$_},
		  );
       }
return join ',',@list;
}

#### StackFrame ####

package StackFrame;

sub new
{
my ($class,$frame)=@_;

my $data={'iterator' => '',
          'item'     => '',
	  'result'   => '',
	  'const'    => ''};
if(defined($frame))
  {
  while(my($name,$value)=each(%{$frame}))
       {
       $data->{$name}=$value;
       }
  }
return bless $data,$class;
}

sub getIterator
{
my ($self)=@_;

return $self->{'iterator'};
}

sub setIterator
{
my ($self,$value)=@_;

return $self->{'iterator'}=$value;
}

sub getItem
{
my ($self)=@_;

return $self->{'item'};
}

sub setItem
{
my ($self,$value)=@_;

return $self->{'item'}=$value;
}

sub getResult
{
my ($self)=@_;

return $self->{'result'};
}

sub setResult
{
my ($self,$value)=@_;

return $self->{'result'}=$value;
}

sub getConst
{
my ($self)=@_;

return $self->{'const'};
}

sub setConst
{
my ($self,$value)=@_;

return $self->{'const'}=$value;
}

#### Stack ####

package Stack;

sub new
{
my ($class)=@_;

$self=bless {'stack' => []},$class;
$self->push();
return $self;
}

sub top
{
my ($self)=@_;

return ${$self->{'stack'}}[$#{$self->{'stack'}}];
}

sub pop
{
my ($self)=@_;

return pop @{$self->{'stack'}};
}

sub push
{
my ($self)=@_;

return push @{$self->{'stack'}},StackFrame->new($self->top());
}

#### Token ####

package Token;

sub new
{
my ($class,$n)=@_;

return bless {'token' => ::drop($n)},$class;
}

sub getToken
{
my ($self)=@_;

return $self->{'token'};
}

sub process
{
my ($self)=@_;

::body($self->getToken());
}

#### Text ####

package Text;

@ISA=qw(Token);

sub new
{
my ($class)=@_;

my $i=index $::Line,'<';
$i=$i<0 ? length($::Line) : $i;
return Token::new($class,$i);
}

sub process
{
my ($self)=@_;

::body(::subVarsText($self->getToken()));
}

#### QuotedToken ####

package QuotedToken;

@ISA=qw(Token);

sub new
{
my ($class,$quote)=@_;

my $i;
::more() while(($i=index($::Line,$quote))<0 && !$::Eof);
$::Line.=$quote if $i<0;
$i=index($::Line,$quote)+length($quote);
return Token::new($class,$i);
}

#### Tag ####

package Tag;

@ISA=qw(Token);

sub new
{
my ($class)=@_;

::more() while($::Line !~ /^<(([^>'"]*)|('[^']*')|("[^"]*"))*>/s && !$::Eof);
my ($token)=$::Line =~ /^(<(([^>'"]*)|('[^']*')|("[^"]*"))*>)/s;
my $self=Token::new($class,length($token));
$token=substr $token,1,-1;
($self->{'name'},$token)=$token=~/^\s*(\/?\w+)(.*)$/s;
$self->{'name'}=lc $self->{'name'};
$self->{'args'}={};
$self->{'types'}={};
::splitParams($token,$self->{'args'},$self->{'types'});
return $self;
}

sub getName
{
my ($self)=@_;

return $self->{'name'};
}

sub getArgs
{
my ($self)=@_;

return $self->{'args'};
}

sub getTypes
{
my ($self)=@_;

return $self->{'types'};
}

sub getTypedArg
{
my ($self,$name,$default)=@_;

return ::subTypedValue($self->{'types'}->{$name},$default,
                       $self->{'args'}->{$name});
}

sub getConstArg
{
my ($self,$name)=@_;

return $self->getTypedArg($name,'$');
}

sub getExpressionArg
{
my ($self,$name)=@_;

return $self->getTypedArg($name,'!');
}

sub getConcatArg
{
my ($self,$name)=@_;

return $self->getTypedArg($name,'#');
}

sub getVarArg
{
my ($self,$name)=@_;

return $self->getTypedArg($name,'%');
}

sub process
{
my ($self)=@_;

my $tagName=lc $self->getName();
my $name=$tagName;
$name=~tr/\//_/;
$name='el'.ucfirst($name);
if($self->can($name))
  {
  &$name($self);
  }
elsif(defined($::Macros{$tagName}))
  {
  $::Line=$::Macros{$self->getName()}->getInstance($self->getArgs(),
                                                   $self->getTypes()).$::Line;
  }
elsif(defined($::Elements{$tagName}))
  {
  ::request($::Elements{$tagName}->getFile());
  my $func=::getElementFuncName($self->getName());
  ::body("<?php $func(",
         $::Elements{$tagName}->getParams($self->getArgs(),
	                                  $self->getTypes()),'); ?>');
  }
else
  {
  ::body(::subVarsText($self->getToken()));
  }
}

sub elAsp
{
::body('<?php ?>');
}

sub elRefresh #XXX Possibly empty period,url
{
my ($self)=@_;

my $period=$self->getVarArg('period');
my $url=$self->getVarArg('url');
::header("<?php header('Refresh: '.$period.'; URL='.$url); ?>\n");
::body("<meta http-equiv='Refresh' value='<?php echo $period
                                           ?>;URL=<?php echo $url ?>'>\n");
}

sub elHtml
{
my ($self)=@_;

::request('lib/errorreporting.php');
::request('lib/database.php');
::request('lib/session.php');
::request('lib/no-cache.php');
::request('lib/charsets.php');
::header(<<EOT);
<?php
noCacheHeaders();
dbOpen();
session();
ob_start();
?>
EOT
::body(<<EOT);
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<?php noCacheMeta() ?>
EOT
::body($self->getToken());
}

sub el_html
{
my ($self)=@_;

::footer(<<EOT);
<?php
\$Output=ob_get_contents();
ob_end_clean();
echo convertOutput(\$Output,\$userReadKOI>0);
dbClose();
?>
EOT
::body($self->getToken());
}

sub elMail
{
my ($self)=@_;

::request('lib/errorreporting.php');
::request('lib/database.php');
::request('lib/session.php');
::request('lib/mail.php');
::header(<<EOT);
<?php
parse_str(\$argv[1]);
dbOpen();
session(\$argv[2]);
ob_start();
?>
EOT
}

sub el_mail
{
my ($self)=@_;

::footer(<<EOT);
<?php
\$Output=ob_get_contents();
ob_end_clean();
echo convertMailOutput(\$Output);
dbClose();
?>
EOT
}

sub elHead
{
my ($self)=@_;

::request('lib/style.php');
::request('lib/redirs.php');
::body(<<EOT);
<?php redirect(); ?>
<head>
<?php foreach(\$stylesheetList as \$sheet) { ?>
<link rel='stylesheet' href='/styles/<?php echo "\$sheet-".getStyle(\$userStyle) ?>.css'>
<?php include("styles/\$sheet-".getStyle(\$userStyle).'.php'); } ?>
EOT
$AfterRedirect=1;
}

sub elA
{
my ($self)=@_;

my $token=$self->getToken();
$token=~s/>/ target='$::Retarget'>/ if $::Retarget ne ''
                                    && $self->getConstArg('target') eq '';
::body(::subVarsText($token));
}

sub elRequire
{
my ($self)=@_;

::request($self->getConstArg('name'));
}

sub elInclude
{
my ($self)=@_;

::body('<?php include(',$self->getVarArg('name'),'); ?>');
}

sub pushArray
{
($self,$array,$name)=@_;

if(exists $self->getArgs()->{$name})
  {
  my $value=$self->getVarArg($name);
  if($value=~/^'([^']*)'$/)
    {
    $value=~s/^'([^']*)'$/\1/;
    push(@$array,map("'$_'",split(/[\s,]+/,$value)));
    }
  else
    {
    push @$array,$value;
    }
  }
}

sub elArray
{
my ($self)=@_;

my $name=$self->getConstArg('name');
$name='const'.($::LastConst++) if $name eq '';
::body("<?php \$$name=array(");
my @vals=();
$self->pushArray(\@vals,'vals');
for(my $n=1;exists $self->getArgs()->{"val$n"};$n++)
   {
   $self->pushArray(\@vals,"val$n");
   }
::body(join(',',@vals),'); ?>');
$::Stack->top()->setConst($name);
}

sub elAssign #XXX Possibly empty value
{
my ($self)=@_;

my $name=$self->getConstArg('name');
$name='const'.($::LastConst++) if $name eq '';
::body("<?php \$$name=",$self->getVarArg('value'),'; ?>');
$::Stack->top()->setConst($name);
}

sub elAssign_global #XXX Possibly empty value
{
my ($self)=@_;

::getGlobal($self->getConstArg('name'));
elAssign @_;
}

sub elIterate #XXX Possibly empty class
{
my ($self)=@_;

my $name=$self->getConstArg('name');
$name='iter'.($::LastIter++) if $name eq '';
::body("<?php \$$name=new ",$self->getConstArg('class'),
       '(',::constructParams($self->getArgs(),$self->getTypes()),'); ?>');
$::Stack->top()->setIterator($name);
}

sub elFor #XXX Possibly empty list
{
my ($self)=@_;

my $list=$self->getConstArg('list');
$list=$::Stack->top()->getIterator() if $list eq '';
my $name=$self->getConstArg('name');
$name='item'.($::LastItem++) if $name eq '';
::body("<?php while(\$$name=\$$list->next()) { ?>");
$::Stack->push();
$::Stack->top()->setItem($name);
}

sub el_for #XXX Possibly incorrect closure
{
my ($self)=@_;

$::Stack->pop();
::body("<?php } ?>");
}

sub elMacro #XXX Possibly empty name
{
my ($self)=@_;

my $body='';
my $level=1;
while($level!=0 && $::Line ne '')
     {
     ::pullToken();
     if(ref($::Token) eq 'Tag')
       {
       $level++ if $::Token->getName() eq 'macro';
       $level-- if $::Token->getName() eq '/macro';
       }
     $body.=$::Token->getToken() if $level!=0;
     }
$::Macros{lc $self->getConstArg('name')}=
   Macro->new($body,$self->getConstArg('defaults'));
}

sub elIf
{
my ($self)=@_;

::body('<?php if(',$self->getExpressionArg('what'),') { ?>');
}

sub elElse #XXX Possibly incorrect closure
{
my ($self)=@_;

::body('<?php } else { ?>');
}

sub el_if #XXX Possibly incorrect closure
{
my ($self)=@_;

::body('<?php } ?>');
}

sub elObj #XXX Possibly empty class
{
my ($self)=@_;

my $name=$self->getConstArg('name');
$name='result'.($::LastResult++) if $name eq '';
::body("<?php \$$name=new ",$self->getConstArg('class'),
       '(',::constructParams($self->getArgs(),$self->getTypes()),'); ?>');
$::Stack->top()->setResult($name);
}

sub elCall #XXX Possibly empty func
{
my ($self)=@_;

my $name=$self->getConstArg('name');
$name='result'.($::LastResult++) if $name eq '';
my $el=$self->getVarArg('element');
if($el ne '' && $el ne "''")
  {
  if($el=~/^'([^']*)'$/)
    {
    $func=::getElementFuncName($1);
    }
  else
    {
    ::body("<?php \$cel='display'.strtr(".$el.",'/','_'); ?>");
    $func='$cel';
    }
  }
else
  {
  $func=$self->getConstArg('func');
  }
my $obj=$self->getVarArg('object');
$obj=$obj!~/^'[^']*'$/ ? "$obj->" : '';
::body("<?php \$$name=$obj$func(",
       ::constructParams($self->getArgs(),$self->getTypes()),'); ?>');
$::Stack->top()->setResult($name);
}

sub elExec #XXX Possibly empty func
{
my ($self)=@_;

my $el=$self->getVarArg('element');
if($el ne '' && $el ne "''")
  {
  if($el=~/^'([^']*)'$/)
    {
    $func=::getElementFuncName($1);
    }
  else
    {
    ::body("<?php \$cel='display'.strtr(".$el.",'/','_'); ?>");
    $func='$cel';
    }
  }
else
  {
  $func=$self->getConstArg('func');
  }
my $obj=$self->getVarArg('object');
$obj=$obj!~/^'[^']*'$/ ? "$obj->" : '';
::body("<?php $obj$func(",
       ::constructParams($self->getArgs(),$self->getTypes()),'); ?>');
}

sub elHeader
{
my ($self)=@_;

$::BodyToHeader++;
}

sub el_header
{
my ($self)=@_;

$::BodyToHeader--;
}

sub elDecel #XXX Possibly empty name
{
my ($self)=@_;

$::Elements{lc $self->getConstArg('name')}=
   Element->new(
             $self->getConstArg('file'),
             $self->getConstArg('params'),
             $self->getConstArg('defaults')
            );
}

sub elElement #XXX Possibly empty name or incorrect closure
{
my ($self)=@_;

$::ElementName=lc $self->getConstArg('name');
$::ElementName=~s/\//_/g;
$::ElementBody='';
@::ElementGlobals=();
if(!exists $::Elements{$::ElementName})
  {
  $::Elements{$::ElementName}=Element->new('',$self->getConstArg('params'),
					   $self->getConstArg('defaults'));
  }
$::Stack->push();
}

sub el_element #XXX Possibly incorrect closure
{
my ($self)=@_;

$::Stack->pop();
my $name=$::ElementName;
$::ElementName='';
my @params=map "\$$_",@{$::Elements{$name}->{'params'}};
my $globals='';
$globals="global ".join(',',map {"\$$_"} @::ElementGlobals).";\n"
         if scalar(@::ElementGlobals)>0;
::body("<?php\nfunction display$name(",join(',',@params),")\n{\n",
       $globals,"?>\n",$::ElementBody,"<?php\n}\n?>\n");
}

sub elSettype #XXX Possibly empty name,type or unknown type
{
my ($self)=@_;

my $name=$self->getConstArg('name');
my $type=$self->getConstArg('type');
my $method=$self->getConstArg('method');
$method=$method eq '' ? 'GET' : uc $method;
::body(<<EOT);
<?php
settype(\$$name,'$type');
settype(\$HTTP_${method}_VARS['$name'],'$type');
?>
EOT
}

sub elSetup
{
my ($self)=@_;

my $name=$self->getConstArg('name');
$name=$::Stack->top()->getResult() if $name eq '';
if($self->getConstArg('var') eq '')
  {
  my $method=$self->getConstArg('method');
  $method='get' if $method eq '';
  $method=uc $method;
  ::body("<?php \$$name->setup(\$",::getGlobal("HTTP_${method}_VARS"),"); ?>");
  }
else
  {
  ::body("<?php \$$name->set".$self->getConstArg('var').
         '('.$self->getVarArg('value').'); ?>');
  }
}

sub elZone
{
my ($self)=@_;

$::Stack->push();
}

sub el_zone
{
my ($self)=@_;

$::Stack->pop();
}

sub elRetarget
{
my ($self)=@_;

$::Retarget=$self->getVarArg('target');
}

sub elNoparse
{
my ($self)=@_;

my $level=1;
while($level!=0 && $::Line ne '')
     {
     ::pullToken();
     if(ref($::Token) eq 'Tag')
       {
       $level++ if $::Token->getName() eq 'noparse';
       $level-- if $::Token->getName() eq '/noparse';
       }
     ::body($::Token->getToken()) if $level!=0;
     }
}

#### Comment ####

package Comment;

@ISA=qw(QuotedToken);

sub new
{
my ($class)=@_;

return QuotedToken::new($class,'-->');
}

sub process
{
my ($self)=@_;

::body(::subVarsText($self->getToken()));
}

#### Remark ####

package Remark;

@ISA=qw(QuotedToken);

sub new
{
my ($class)=@_;

return QuotedToken::new($class,'>>');
}

sub process
{
}

#### PHP ####

package PHP;

@ISA=qw(QuotedToken);

sub new
{
my ($class)=@_;

return QuotedToken::new($class,'?>');
}

#### main ####

package main;

use Getopt::Long;
Getopt::Long::Configure('no_auto_abbrev','no_ignore_case','bundling');

$VERSION='0.2';

sub more
{
return if $Eof;
my $s=<>;
if(defined($s))
  {
  $Line.=$s;
  }
else
  {
  $Eof=1;
  }
}

sub pull
{
more() while(!$Eof && $Line eq '');
}

sub drop
{
my $n=shift;

my $s=substr($Line,0,$n);
$LineN+=$s=~tr/\n/\n/;
substr($Line,0,$n)='';
pull;
return $s;
}

sub pullToken
{
my $quote='';
my $class='';
while(my($q,$c)=each(%Quotes))
     {
     if(substr($Line,0,length($q)) eq $q && length($q)>=length($quote))
       {
       $quote=$q;
       $class=$c;
       }
     }
my $name=$class.'::new';
return $Token=&$name($class);
}

sub request
{
my ($name)=@_;

push @Requests,$name unless $name eq '' or grep {$_ eq $name} @Requests;
}

sub printVar
{
$var=shift;
$data=join '',@_;
if($$var=~/\n$/ || $$var eq '')
  {
  $data=~s/^\s+//;
  }
else
  {
  $data=~s/^\s*\n\s*/\n/;
  }
$$var.=$data;
$$var=~s/\s\?>\s*\n\s*<\?php\s/\n/sg;
$$var=~s/\s\?>\s*<\?php\s//sg;
}

sub header
{
printVar(\$Header,@_);
}

sub body
{
if($BodyToHeader)
  {
  header(@_);
  }
elsif($ElementName ne '')
  {
  printVar(\$ElementBody,@_);
  }
else
  {
  printVar(\$Body,@_);
  }
}

sub footer
{
printVar(\$Footer,@_);
}

sub display
{
print STDERR @_;
}

sub help
{
print <<EOF;
Usage: $0 [<options>] [<file>]

Migdal website kernel MHTML macro language preprocessor

  -h, --help                Print this help and exit
  -M, --macros=<filename>   Set macro file path (default is `macros.mhtml')
  -v, --version             Print version information and exit

Report bugs to <balu\@migdal.ru>
EOF
exit;
}

sub version
{
print <<EOF;
miparser (migdal $VERSION)
Copyright (C) 2001-02 by Dmitry E. Melamud.

This program is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public
License (see LICENSE).

EOF
exit;
}

sub macros
{
my (undef,$macros)=@_;

unshift @ARGV,$macros if -r $macros;
}

sub init
{
$|=1;
GetOptions('help|h|?'	=> \&help,
           'macros|M=s'	=> \&macros,
           'version|v'	=> \&version);
$Stack=Stack->new();
pull;
}

sub run
{
while($Line ne '')
     {
     pullToken;
     $Token->process();
     }
}

sub done
{
my $s="<?php\n";
foreach(@Requests)
       {
       $s.="require_once('$_');\n";
       }
$s.="?>\n";
$s.=$Header.$Body.$Footer;
$s=~s/\s\?>\s*\n\s*<\?php\s/\n/sg;
$s=~s/\s\?>\s*<\?php\s//sg;
print $s;
}

init;
run;
done;
