#!/usr/bin/perl

# @(#) $Id$

$Line='';
$LineN=1;
$Eof=0;
$Token='';

%Quotes=('<!--' => 'Comment',
         '<?'   => 'PHP',
	 '<<'   => 'Remark',
         '<'    => 'Tag',
	 ''     => 'Text');
	 
@Requests=();
$Header='';
$Body='';
$Footer='';

$BodyToHeader=0;

$LastIter='';
$LastItem='';

$Stack='';

%Macros=();
%Elements=();

#### Utility functions ####

sub constructRemake
{
my ($s)=@_;

@del=();
@subs=();
%params=();
request('lib/utils.php');
splitParams($s,\%params);
while(my($name,$value)=each(%params))
     {
     if($value eq '')
       {
       push @del,"'$name'";
       }
     else
       {
       push @subs,"'$name' => ".subVar($value);
       }
     }
return 'remakeURI($REQUEST_URI,array('.join(',',@del).'),array('
                                      .join(',',@subs).'))';
}

sub subVar
{
my ($s,$st,$ed)=@_;

my $item=$Stack->top()->getItem();

return $st.constructRemake($1).$ed if $s=~/^\$\[([^\]]*)\]$/;
return "$st$1$ed" if $s=~/^\*(\w+)$/;
return "${st}urlencode(\$REQUEST_URI)$ed" if $s=~/^\$_$/;
return "$st\$$1$ed" if $s=~/^\$(\w+)$/;
return "$st\$$1$ed" if $s=~/^\$\$(\w+)$/;
return "${st}urlencode(\$$1)$ed" if $s=~/^\$%(\w+)$/;
return "$st\$$item->get$1()$ed" if $s=~/^\$\.(\w+)$/;
return "$st\$$1->get$2()$ed" if $s=~/^\$(\w+)\.(\w+)$/;
return "${st}urlencode(\$$item->get$1())$ed" if $s=~/^\$%\.(\w+)$/;
return "${st}urlencode(\$$1->get$2())$ed" if $s=~/^\$%(\w+)\.(\w+)$/;
return "'$st$s$ed'";
}

sub subVars
{
my ($s,$st,$ed)=@_;
my $c='';

while($s ne '')
     {
     my $head,$var;
     ($head,$var,$s)=$s=~/^([^\$]*)((?:(?:\$[%\$]?(?:(?:\w*\.?\w+)|(?:\[[^\]]*\])|_))|(?:\*\w+))?)(.*)$/;
     $c.=$head;
     $c.=subVar($var,$st,$ed) if $var ne '';
     }
return $c;
}

sub subVarsText
{
my ($s)=@_;

return subVars($s,'<?php echo ',' ?>');
}

sub subMacroParams
{
my ($s,$params)=@_;

$s=~s/%(\w+)/$params->{$1}/ge;
return $s;
}

sub splitParams
{
my ($token,$args)=@_;

while($token!~/^\s*$/)
     {
     my $name,$value;
     ($name,$value,$token)=
         $token=~/^\s*(\w+)\s*(?:=\s*((?:[^\s'"]+)|(?:'[^']*')|(?:"[^"]*")))?(.*)$/s;
     $value=substr $value,1,-1 if $value=~/^['"]/;
     $args->{lc $name}=$value;
     }
}

sub constructParams
{
my ($args)=@_;

my @params=();
for(my $n=1;exists $args->{"arg$n"};$n++)
   {
   push @params,subVar($args->{"arg$n"});
   }
return join ',',@params;
}

#### Macro ####

package Macro;

sub new
{
my ($class,$body,$defaults)=@_;

my $self=bless {'body' => $body},$class;
$self->{'defaults'}={};
::splitParams($defaults,$self->{'defaults'});
return $self;
}

sub getBody
{
my ($self)=@_;

return $self->{'body'};
}

sub getInstance
{
my ($self,$params)=@_;

my %args=();
while(my($name,$value)=each(%{$self->{'defaults'}}))
     {
     $args{$name}=$value;
     }
while(my($name,$value)=each(%{$params}))
     {
     $args{$name}=$value;
     }
my $s=::subMacroParams($self->getBody(),\%args);
return $s;
}

#### Element ####

package Element;

sub new
{
my ($class,$file,$params,$defaults)=@_;

my $self=bless {'file' => $file},$class;
$params=~s/^\s+//;
$params=~s/\s+$//;
$self->{'params'}=[];
@{$self->{'params'}}=map{s/^\$//;$_} split(/[\s,]+/,$params);
$self->{'defaults'}={};
::splitParams($defaults,$self->{'defaults'});
return $self;
}

sub getFile
{
my ($self)=@_;

return $self->{'file'};
}

sub getParams
{
my ($self,$args)=@_;

my @list=();
foreach(@{$self->{'params'}})
       {
       push @list,::subVar(exists $args->{$_} ? $args->{$_}
                                              : $self->{'defaults'}->{$_});
       }
return join ',',@list;
}

#### StackFrame ####

package StackFrame;

sub new
{
my ($class,$frame)=@_;

my $data={'iterator' => '',
          'item'     => ''};
if(defined($frame))
  {
  $data->{$name}=$value while(my($name,$value)=each(%{$frame}));
  }
return bless $data,$class;
}

sub getIterator
{
my ($self)=@_;

return $self->{'iterator'};
}

sub setIterator
{
my ($self,$value)=@_;

return $self->{'iterator'}=$value;
}

sub getItem
{
my ($self)=@_;

return $self->{'item'};
}

sub setItem
{
my ($self,$value)=@_;

return $self->{'item'}=$value;
}

#### Stack ####

package Stack;

sub new
{
my ($class)=@_;

$self=bless {'stack' => []},$class;
$self->push();
return $self;
}

sub top
{
my ($self)=@_;

return ${$self->{'stack'}}[$#{$self->{'stack'}}];
}

sub pop
{
my ($self)=@_;

return pop @{$self->{'stack'}};
}

sub push
{
my ($self)=@_;

return push @{$self->{'stack'}},StackFrame->new($self->top());
}

#### Token ####

package Token;

sub new
{
my ($class,$n)=@_;

return bless {'token' => ::drop($n)},$class;
}

sub getToken
{
my ($self)=@_;

return $self->{'token'};
}

sub process
{
my ($self)=@_;

::body($self->getToken());
}

#### Text ####

package Text;

@ISA=qw(Token);

sub new
{
my ($class)=@_;

my $i=index $::Line,'<';
$i=$i<0 ? length($::Line) : $i;
return Token::new($class,$i);
}

sub process
{
my ($self)=@_;

::body(::subVarsText($self->getToken()));
}

#### QuotedToken ####

package QuotedToken;

@ISA=qw(Token);

sub new
{
my ($class,$quote)=@_;

my $i;
::more() while(($i=index($::Line,$quote))<0 && !$::Eof);
$::Line.=$quote if $i<0;
$i=index($::Line,$quote)+length($quote);
return Token::new($class,$i);
}

#### Tag ####

package Tag;

@ISA=qw(Token);

sub new
{
my ($class)=@_;

::more() while($::Line !~ /^<(([^>'"]*)|('[^']*')|("[^"]*"))*>/s && !$::Eof);
my ($token)=$::Line =~ /^(<(([^>'"]*)|('[^']*')|("[^"]*"))*>)/s;
my $self=Token::new($class,length($token));
$token=substr $token,1,-1;
($self->{'name'},$token)=$token=~/^\s*(\/?\w+)(.*)$/s;
$self->{'name'}=lc $self->{'name'};
$self->{'args'}={};
::splitParams($token,$self->{'args'});
return $self;
}

sub getName
{
my ($self)=@_;

return $self->{'name'};
}

sub getArgs
{
my ($self)=@_;

return $self->{'args'};
}

sub getArg
{
my ($self,$name)=@_;

return $self->{'args'}->{$name};
}

sub process
{
my ($self)=@_;

my $name=$self->getName();
$name=~tr/\//_/;
$name='el'.ucfirst($name);
if($self->can($name))
  {
  &$name($self);
  }
elsif(defined($::Macros{$self->getName()}))
  {
  $::Line=$::Macros{$self->getName()}->getInstance($self->getArgs()).$::Line;
  }
elsif(defined($::Elements{$self->getName()}))
  {
  ::request($::Elements{$self->getName()}->getFile());
  ::body('<?php display',$self->getName(),'(',
         $::Elements{$self->getName()}->getParams($self->getArgs()),') ?>');
  }
else
  {
  ::body(::subVarsText($self->getToken()));
  }
}

sub elHtml
{
my ($self)=@_;

::request('lib/errorreporting.php');
::request('lib/database.php');
::request('lib/session.php');
::header(<<EOT);
<?php
dbOpen();
session();
?>
EOT
::body($self->getToken());
}

sub el_html
{
my ($self)=@_;

::footer(<<EOT);
<?php
dbClose();
?>
EOT
::body($self->getToken());
}

sub elRequire
{
my ($self)=@_;

::request($self->getArg('name'));
}

sub elIterate #XXX Possibly empty class
{
my ($self)=@_;

my $name=$self->getArg('name');
$name='iter'.($::LastIter++) if $name eq '';
$::Stack->top()->setIterator($name);
::body("<?php \$$name=new ",$self->getArg('class'),
       '(',::constructParams($self->getArgs()),') ?>');
}

sub elFor #XXX Possibly empty list
{
my ($self)=@_;

my $list=$self->getArg('list');
$list=$::Stack->top()->getIterator() if $list eq '';
my $name=$self->getArg('name');
$name='item'.($::LastItem++) if $name eq '';
::body("<?php while(\$$name=\$$list->next()) { ?>");
$::Stack->push();
$::Stack->top()->setItem($name);
}

sub el_for #XXX Possibly incorrect closure
{
my ($self)=@_;

$::Stack->pop();
::body("<?php } ?>");
}

sub elMacro #XXX Possibly empty name
{
my ($self)=@_;

my $body='';
::pullToken();
while((ref($::Token) ne 'Tag' || $::Token->getName() ne '/macro')
      && $::Line ne '')
     {
     $body.=$::Token->getToken();
     ::pullToken();
     }
$::Macros{$self->getArg('name')}=Macro->new($body,$self->getArg('defaults'));
}

sub elIf
{
my ($self)=@_;

::body('<?php if(',::subVars($self->getArg('what')),') { ?>');
}

sub elElse #XXX Possibly incorrect closure
{
my ($self)=@_;

::body('<?php } else { ?>');
}

sub el_if #XXX Possibly incorrect closure
{
my ($self)=@_;

::body('<?php } ?>');
}

sub elObj #XXX Possibly empty name,class
{
my ($self)=@_;

::body('<?php $',$self->getArg('name'),'=new ',$self->getArg('class'),
       '(',::constructParams($self->getArgs()),') ?>');
}

sub elHeader
{
my ($self)=@_;

$::BodyToHeader=1;
}

sub el_header
{
my ($self)=@_;

$::BodyToHeader=0;
}

sub elDecel #XXX Possibly empty name
{
my ($self)=@_;

$::Elements{$self->getArg('name')}=Element->new($self->getArg('file'),
                                                $self->getArg('params'),
                                                $self->getArg('defaults'));
}

sub elSettype #XXX Possibly empty name,type or unknown type
{
my ($self)=@_;

::body('<?php settype($',$self->getArg('name'),',\'',
                         $self->getArg('type'),'\') ?>');
}

#### Comment ####

package Comment;

@ISA=qw(QuotedToken);

sub new
{
my ($class)=@_;

return QuotedToken::new($class,'-->');
}

#### Remark ####

package Remark;

@ISA=qw(QuotedToken);

sub new
{
my ($class)=@_;

return QuotedToken::new($class,'>>');
}

sub process
{
}

#### PHP ####

package PHP;

@ISA=qw(QuotedToken);

sub new
{
my ($class)=@_;

return QuotedToken::new($class,'?>');
}

#### main ####

package main;

sub more
{
return if $Eof;
my $s=<>;
if(defined($s))
  {
  $Line.=$s;
  }
else
  {
  $Eof=1;
  }
}

sub pull
{
more() while(!$Eof && $Line eq '');
}

sub drop
{
my $n=shift;

my $s=substr($Line,0,$n);
$LineN+=$s=~/\n/;
substr($Line,0,$n)='';
pull;
return $s;
}

sub pullToken
{
my $quote='';
my $class='';
while(my($q,$c)=each(%Quotes))
     {
     if(substr($Line,0,length($q)) eq $q && length($q)>=length($quote))
       {
       $quote=$q;
       $class=$c;
       }
     }
my $name=$class.'::new';
return $Token=&$name($class);
}

sub request
{
my ($name)=@_;

push @Requests,$name unless $name eq '' or grep {$_ eq $name} @Requests;
}

sub printVar
{
$var=shift;
$data=join '',@_;
if($$var=~/\n$/ || $$var eq '')
  {
  $data=~s/^\s+//;
  }
else
  {
  $data=~s/^\s*\n\s*/\n/;
  }
$$var.=$data;
}

sub header
{
printVar(\$Header,@_);
}

sub body
{
if($BodyToHeader)
  {
  header(@_);
  }
else
  {
  printVar(\$Body,@_);
  }
}

sub footer
{
printVar(\$Footer,@_);
}

sub display
{
print STDERR @_;
}

sub init
{
$|=1;
$Stack=Stack->new();
unshift @ARGV,'macros.mhtml' if -r 'macros.mhtml';
pull;
}

sub run
{
while($Line ne '')
     {
     pullToken;
     $Token->process();
     }
}

sub done
{
print "<?php\n";
foreach(@Requests)
       {
       print "require_once('$_');\n";
       }
print "?>\n";
print $Header,$Body,$Footer;
}

init;
run;
done;
