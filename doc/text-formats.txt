Форматы хранения текстов
========================

Ядро различает, в основном, 4 формата текстов:

1. Входной - тот, в котором пользователь ввел информацию.
2. Внутренний - в котором хранится информация в БД.
3. mtext - XML-формат, полуподготовленный для вывода, для более легкой
   конвертации в HTML, нежели внутренний. Используется не всегда.
4. Выходной - тот, в котором информация отдается пользователю.

Кодировки используется две: внутренняя и внешняя. Внешняя - это входная и
выходная кодировки (они совпадают - из-за ошибок в IE сделать по-другому
невозможно). Внутренняя используется внутри PHP-кода, в БД и для mtext (но
посколько XML допускает только Unicode, перед обработкой XML-парсерами mtext
перекодируется в UTF-8).

Если текст загружается в виде файла, его кодировку нельзя определить никак,
кроме как частотным анализом.

Все символы, которые отсутствуют в выбранной кодировке, представляются через
character entities (&#<код символа>;). При преобразовании кодировок такие
символы выявляются и кодируются. Обратное преобразование - раскодировка
character entities - производится только при перекодировании в UTF-8 или
UTF-16. Соответственно, внутренняя и внешняя кодировки должны подбираться так,
чтобы в них попадала бОльшая часть символов, используемых на сайте.

Для ввода с клавиатуры таких символов как длинное тире, кавычки-"елочки", знак
номера и т.п., используются лигатуры, т.е. специальные последовательности
символов, которые преобразуются в один нужный.

Лигатуры:

<<	левая кавычка-"елочка"
>>	правая кавычка-"елочка"
---	длинное тире
``	левая кавычка-"лапка"
''	правая кавычка-"лапка"
(c)	знак копирайта
(r)	знак регистрации
(tm)	знак торговой марки
No.	знак номера
&sp;	пробел (используется там, где пробелы удаляются)
&nil;	ничто (вставляется для "расщепления" лигатур, чтобы они не были
        преобразованы, например <&nil;< - это просто два знака <<)

Еще одна лигатура - последовательность $<символы>$ преобразуется в ивритские
буквы. Таблицу соответствия см. в doc/hebrew.txt.

Форматирование в тексте может быть представлено во многих форматах -
WikiSyntax, BBCode, XML - зависит только от наличия соответствующего
конвертера в mtext.

Преобразование безопасности заменяет все символы < на &lt;, чтобы в выходной
HTML не попали неразрешенные таги.

В итоге, разные фрагменты текста, в зависимости от того, где и как они были
введены, подвергаются вышеперечисленным преобразованиям на разных этапах своей
биографии "ввод-хранение-вывод".

Текст в файлах исходников
-------------------------

Этот текст считается подготовленным в плане форматирования и character
entities. Считается, что он написан во внутренней кодировке. Поэтому он
подвергается только преобразованию в выходную кодировку в самом конце вместе
со всем содержимым страницы.

Текст без форматирования
------------------------

Заголовки, имена и прочий простой текст без форматирования подвергается
преобразованиям кодировок и лигатур в момент, когда он копируется из
параметров GET/POST-запроса во внутренние переменные (см. функцию
postString()).  Преобразование безопасности производится при вставке текста в
страницу при помощи подстановок вида $=переменная. В выходную кодировку текст
преобразуется вместе со всей остальной страницей.

Текст с форматированием
-----------------------

Текст с форматированием преобразуется во внутреннюю кодировку в момент
postString(). В момент сохранения в базу его копия преобразуется в формат
mtext в такой последовательности: преобразование безопасности, формата. При
вставке в страницу mtext преобразуется в HTML (см. методы BodyHTML(),
AuthorHTML() и т.п.). В выходную кодировку текст преобразуется вместе со всей
остальной страницей.

Если нужно выдать текст в исходном виде, берется его версия, не преобразованная
в mtext, и она подвергается преобразованию безопасности (при выдаче в
формате HTML) или только преобразованию кодировок (при выдаче в формате plain
text).

Для того, чтобы пользователь мог вводить символы, выходящие за рамки выходной
кодировки, текст, выдаваемый в исходном виде, должен подвергаться еще одному
преобразованию - все такие символы должны выдаваться в виде character entities.
Для этого должна существовать специальная подстановка для всех текстов,
выдаваемых в исходном виде. На данный момент такой подстановки нет. Это
означает, что ввод символов ограничен рамками выходной кодировки.

@(#) $Id$
