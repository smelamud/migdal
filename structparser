#!/usr/bin/perl

# @(#) $Id$

use Getopt::Long;
Getopt::Long::Configure('no_auto_abbrev','no_ignore_case','bundling');

$VERSION='0.3';

$outputFileName='-';
@Structure=();

sub help
{
print <<EOF;
Usage: $0 [<options>] [<file>]

Migdal website kernel structure definition language preprocessor

  -h, --help                   Print this help and exit
  -o, --output=<name>          Output file
  -v, --version                Print version information and exit

Report bugs to <balu\@migdal.ru>
EOF
exit;
}

sub version
{
print <<EOF;
structparser (migdal $VERSION)
Copyright (C) 2005 by Dmitry E. Melamud.

This program is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public
License (see LICENSE).

EOF
exit;
}

sub processPathPattern
{
my ($item)=@_;

$$item{'_path_regex'}='^'.$$item{'path'}.'$';
$$item{'_path_regex'}=~s/\//\\\//g;
$$item{'_subs'}=();
while($$item{'_path_regex'}=~/{([^}]*)}/)
     {
     my $name=$1;
     my $type='';
     if($name=~/^(\w+):(\w+)$/)
       {
       ($name,$type)=($1,$2);
       SWITCH: {
               $$item{'_path_regex'}=~s/{([^}]*)}/(.+)/,last if $type eq 'path';
               $$item{'_path_regex'}=~s/{([^}]*)}/([^\\\/]+)/;
	       }
       }
     else
       {
       $$item{'_path_regex'}=~s/{([^}]*)}/([^\\\/]+)/;
       }
     push @{$$item{'_subs'}},$name;
     }
}

sub saveArgs
{
my ($item)=@_;

for my $var(keys %$item)
   {
   next unless $var=~/^arg\.(\w+)/;
   $$item{"_arg.$1"}=$$item{$var};
   }
}

sub processIdOrCatalog
{
my ($item)=@_;

for my $var(keys %$item)
   {
   next unless $var=~/^arg\.(\w+)/;
   my $name="_arg.$1";
   next unless $$item{$name}=~/^(.*)\|(.*)$/;
   $$item{$name}="\".idOrCatalog(\"$1\",\"$2\").\"";
   }
}

sub postProcessArgs
{
my ($item)=@_;

for my $var(keys %$item)
   {
   next unless $var=~/^arg\./;
   my $type;
   ($var,$type)=$var=~/^arg\.(\w+):(\w+)$/;
   $type=ucfirst $type;
   $$item{"_arg.$var"}="\".postProcess$type(\"".$$item{"_arg.$var"}."\").\"";
   }
}

sub processArgs
{
my ($item)=@_;

saveArgs($item);
processIdOrCatalog($item);

my $n=1;
for my $sub(@{$$item{'_subs'}})
   {
   for my $var(keys %$item)
      {
      next unless $var=~/^arg\./ || $var eq 'parent.path';
      $var="_arg.$1" if $var=~/^arg\.(\w+):\w+$/;
      $$item{$var}=~s/\${$sub}/"{\$m[$n]}"/ge;
      }
   $n++;
   }

postProcessArgs($item);
}

sub subTitleVar
{
my ($expr)=@_;

return "{\$args['$1']}" if $expr=~/^arg\.(\w+)$/;
return "\".\$info->parent->getTitle().\"" if $expr eq 'parent.title';
return "{\$$expr}";
}

sub subTitleFunc
{
my ($expr)=@_;

my ($name,$arg)=$expr=~/^(\w+)\(([^)]*)\)$/;
$name=ucfirst $name;
$arg=subTitleVar($arg);
return "\".title$name(\"$arg\").\"";
}

sub subTitleExpr
{
my ($expr)=@_;

if($expr=~/\(/)
  {
  return subTitleFunc($expr);
  }
else
  {
  return subTitleVar($expr);
  }
}

sub processTitle
{
my ($item)=@_;

my $title=$$item{'title'};
$title=~s/\${([^}]*)}/subTitleExpr($1)/ge;
$$item{'_title'}=$title;
}

sub addItem
{
my ($item)=@_;

return unless exists($$item{'path'});
$path=$$item{'path'};
$path.='/' if substr($path,$#path) ne '/';
$$item{'path'}=$path;
processPathPattern($item) if $path=~/{/;
processArgs($item) if $path=~/{/;
processTitle($item) if exists($$item{'title'});
push @Structure,$item;
}

sub readStructure
{
my $item={};
while(<>)
     {
     s/#.*$//;
     unless(/^\s*([\w.:]+)\s*=\s*(.*)$/)
           {
	   addItem($item);
	   $item={};
	   }
     else
           {
           $$item{$1}=$2;
	   }
     }
addItem($item);
}

sub init
{
$|=1;
GetOptions('help|h|?'	      => \&help,
	   'output|o=s'       => \$outputFileName,
           'version|v'	      => \&version);
open OUT,">$outputFileName";
readStructure;
}

sub run
{
print OUT <<EOF;
<?php
function &getLocationInfo(\$path,\$redirid=0)
{
\$info=new LocationInfo();
\$info->setPath(\$path);
if(substr(\$path,-5)=='.html')
  \$path=substr(\$path,0,-5);
\$path=normalizePath(\$path,true,SLASH_YES,SLASH_YES);
EOF
for my $item(@Structure)
   {
   if(!exists($$item{'_path_regex'}))
     {
     my $path=$$item{'path'};
     print OUT <<EOF;
if(\$path=='$path')
  {
EOF
     }
   else
     {
     my $regex=$$item{'_path_regex'};
     print OUT <<EOF;
if(preg_match('/$regex/',\$path,\$m))
  {
EOF
     }
   my $script=$$item{'script'};
   print OUT <<EOF;
  \$info->setScript('$script');
EOF
   my $f=0;
   for my $key(keys %$item)
       {
       next unless $key=~/^_arg\.([\w:]*)$/;
       if(!$f)
         {
	 print OUT <<EOF;
  \$args=array(
EOF
	 $f=1;
	 }
       my $value=$$item{$key};
       print OUT <<EOF
  '$1' => "$value",
EOF
       }
   if($f)
     {
     print OUT <<EOF
  );
  \$info->setArgs(\$args);
EOF
     }
   if(exists($$item{'parent.path'}))
     {
     my $parent=$$item{'parent.path'};
     print OUT <<EOF
  \$info->setParent(getParentLocationInfo("$parent",\$redirid));
EOF
     }
   if(exists($$item{'_title'}))
     {
     my $title=$$item{'_title'};
     print OUT <<EOF
  \$info->setTitle("$title");
EOF
     }
   print OUT <<EOF;
  return \$info;
  }
EOF
   }
print OUT <<EOF;
return \$info;
}
?>
EOF
}

sub done
{
}

init;
run;
done;
