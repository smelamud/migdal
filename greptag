#!/usr/bin/perl

# @(#) $Id$
# Based-on: miparser 1.77 (разбор MHTML)

$className='';
$tagName='';
$showFilenames=0;

$Line='';
$LineN=0;
@LineText=();
$FileName='';
$FileNameNext='';
$FileLineN=1;
$Eof=0;
$Token='';

%Quotes=('<!--' => 'Comment',
         '<?'   => 'PHP',
	 '<<'   => 'Remark',
         '<'    => 'Tag',
	 ''     => 'Text');

sub splitParams
{
my ($token,$args,$types)=@_;

while($token!~/^\s*$/)
     {
     my $name,$value;
     ($name,$type,$value,$token)=$token=~m/
					   ^\s*(\w+)([\$#%!]?)\s*
					   (?:
					    =\s*
					    (
					     (?: [^\s'"]+ )
					     |
					     (?: '[^']*' )
					     |
					     (?: "[^"]*" )
					    )
					   )?
					   (.*)$
					  /sx;
     $value=substr $value,1,-1 if $value=~/^['"]/;
     $args->{lc $name}=$value;
     $types->{lc $name}=$type if defined($types);
     }
}

#### Token ####

package Token;

sub new
{
my ($class,$n)=@_;

return bless {'token' => ::drop($n)},$class;
}

sub getToken
{
my ($self)=@_;

return $self->{'token'};
}

sub process
{
}

#### Text ####

package Text;

@ISA=qw(Token);

sub new
{
my ($class)=@_;

my $i=index $::Line,'<';
$i=$i<0 ? length($::Line) : $i;
return Token::new($class,$i);
}

#### QuotedToken ####

package QuotedToken;

@ISA=qw(Token);

sub new
{
my ($class,$quote)=@_;

my $i;
::more() while(($i=index($::Line,$quote))<0 && !$::Eof);
$::Line.=$quote if $i<0;
$i=index($::Line,$quote)+length($quote);
return Token::new($class,$i);
}

#### Tag ####

package Tag;

@ISA=qw(Token);

sub new
{
my ($class)=@_;

my $line=$::LineN;
::more() while($::Line !~ /^<(([^>'"]*)|('[^']*')|("[^"]*"))*>/s && !$::Eof);
my ($token)=$::Line =~ /^(<(([^>'"]*)|('[^']*')|("[^"]*"))*>)/s;
my $self=Token::new($class,length($token));
$token=substr $token,1,-1;
($self->{'name'},$token)=$token=~/^\s*(\/?\w+)(.*)$/s;
$self->{'name'}=lc $self->{'name'};
$self->{'args'}={};
$self->{'types'}={};
$self->{'line'}=$line;
::splitParams($token,$self->{'args'},$self->{'types'});
return $self;
}

sub getName
{
my ($self)=@_;

return $self->{'name'};
}

sub getArgs
{
my ($self)=@_;

return $self->{'args'};
}

sub getTypes
{
my ($self)=@_;

return $self->{'types'};
}

sub getArg
{
my ($self,$name)=@_;

return $self->{'args'}->{$name};
}

sub getLine
{
my ($self)=@_;

return $self->{'line'};
}

sub process
{
my ($self)=@_;
my $found=0;

if($::className ne '' && $self->getArg('class') ne '')
  {
  $found=0;
  my @classes=split /\s+/,$self->getArg('class');
  foreach(@classes)
         {
	 $found=1 if /$::className/io;
	 }
  return unless $found;
  }
if($::tagName ne '' && $self->getName() ne '')
  {
  $found=0;
  $found=1 if $self->getName()=~/$::tagName/io;
  return unless $found;
  }
my $text=$::LineText[$self->getLine()];
print $::showFilenames ? $text->{'file'}.':' : '',$text->{'line'},':',
      $text->{'text'} if $found;
}

#### Comment ####

package Comment;

@ISA=qw(QuotedToken);

sub new
{
my ($class)=@_;

return QuotedToken::new($class,'-->');
}

#### Remark ####

package Remark;

@ISA=qw(QuotedToken);

sub new
{
my ($class)=@_;

return QuotedToken::new($class,'>>');
}

#### PHP ####

package PHP;

@ISA=qw(QuotedToken);

sub new
{
my ($class)=@_;

return QuotedToken::new($class,'?>');
}

#### main ####

package main;

use Getopt::Long;
Getopt::Long::Configure('no_auto_abbrev','no_ignore_case','bundling');

$VERSION='0.2';

sub more
{
return if $Eof;
my $s=<>;
if(defined($s))
  {
  $Line.=$s;
  if($FileNameNext ne $ARGV[0])
    {
    $FileLineN=1;
    $FileName=$FileNameNext,$FileNameNext=$ARGV[0];
    }
  else
    {
    $FileLineN++;
    }
  push @LineText,{'file' => $FileName,'line' => $FileLineN,'text' => $s};
  }
else
  {
  $Eof=1;
  }
}

sub pull
{
more() while(!$Eof && $Line eq '');
}

sub drop
{
my $n=shift;

my $s=substr($Line,0,$n);
$LineN+=$s=~tr/\n/\n/;
substr($Line,0,$n)='';
pull;
return $s;
}

sub dropTexts
{
splice @LineText,0,$LineN-1;
$LineN=0;
}

sub pullToken
{
dropTexts;

my $quote='';
my $class='';
while(my($q,$c)=each(%Quotes))
     {
     if(substr($Line,0,length($q)) eq $q && length($q)>=length($quote))
       {
       $quote=$q;
       $class=$c;
       }
     }
my $name=$class.'::new';
return $Token=&$name($class);
}

sub display
{
print STDERR @_;
}

sub help
{
print <<EOF;
Usage: $0 [<options>] [<file> ...]

Look for specified tag/attribute in a set of MHTML files

  -c, --class=<name>    Look for tag with the class <name>
  -h, --help            Print this help and exit
  -n, --name=<name>     Look for tag <name>
  -v, --version         Print version information and exit

Report bugs to <balu\@migdal.ru>
EOF
exit;
}

sub version
{
print <<EOF;
greptag (migdal $VERSION)
Copyright (C) 2002 by Dmitry E. Melamud.

This program is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public
License (see LICENSE).

EOF
exit;
}

sub init
{
$|=1;
GetOptions('class|c=s'  => \$className,
           'help|h|?'	=> \&help,
	   'name|n=s'   => \$tagName,
           'version|v'	=> \&version);
$showFilenames=$#ARGV>0;
$FileNameNext=$ARGV[0];
pull;
}

sub run
{
while($Line ne '')
     {
     pullToken;
     $Token->process();
     }
}

sub done
{
}

init;
run;
done;
