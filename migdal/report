#!/usr/bin/perl

# @(#) $Id$

use Getopt::Long;
Getopt::Long::Configure('no_auto_abbrev','no_ignore_case','bundling');
use POSIX qw(mktime);

$VERSION='0.3';

$directory='.';
$fromDate=0;
$toDate=0;
$report='raw';
$interval=1;
$popularity=0;
$verbose=0;

@topics=();
@postings=();
@messages=();
@imagesets=();
@users=();

package Counter;

sub new
{
my ($class)=@_;

return bless {'value'  => 0,
              'visits' => {}},$class;
}

sub inc
{
my ($self,$addr,$time)=@_;

$self->{'value'}++ if $time-$self->{'visits'}->{$addr}>=$::interval*3600;
$self->{'visits'}->{$addr}=$time;
}

sub getValue
{
my ($self)=@_;

return $self->{'value'};
}

package main;

sub parseDate
{
my ($s)=@_;

my ($day,$month,$year,$hour,$min,$sec)=
  $s=~/^\s*(\d+)[-.\/](\d+)[-.\/](\d+)(?:\s+(\d+)[:.](\d+)(?:[:.](\d+))?)?\s*$/;
return POSIX::mktime($sec,$min,$hour,$day,$month-1,$year-1900);
}

sub fromDate
{
shift;
$fromDate=parseDate(shift);
}

sub toDate
{
shift;
$toDate=parseDate(shift);
}

sub fixEntities
{
my ($s)=@_;

$s=~s/&gt;/>/g;
$s=~s/&lt;/</g;
$s=~s/&quot;/"/g;
$s=~s/&#039;/'/g;
return $s;
}

sub help
{
print <<EOF;
Usage: $0 [<options>]

Migdal report generator (for 'migdal' interface)

  -d, --directory=<path>    Directory, where logs are located (default is
                            current directory)
  -f, --from=<date>         Starting date for statistics
  -h, --help                Print this help and exit
  -i, --interval=<n>        Minimal interval in hours between visits from the
                            same address, considered to be different visits
			    (1 hour by default)
  -p, --popularity=<n>      Minimal popularity to output
  -r, --report=<type>       Output some kind of report
	domains      Domains popularity report
	popularity   Popularity report
        raw          Raw user-readable log (default)
	traps        Traps activity report
	visits       Output number of individual visits
  -t, --to=<date>           Final date for statistics
  -v, --version             Print version information and exit
  -V, --verbose             More verbose

Report bugs to <balu\@yes.ru>
EOF
exit;
}

sub version
{
print <<EOF;
report (migdal $VERSION)
Copyright (C) 2002 by Dmitry E. Melamud.

This program is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public
License (see COPYING).

EOF
exit;
}

sub initTopics
{
open IN,"$directory/topics";
while(<IN>)
     {
     chomp;
     my @line=split /\t/;
     $topics[$line[0]]=fixEntities($line[1]);
     }
close IN;
}

sub initPostings
{
open IN,"$directory/postings";
while(<IN>)
     {
     chomp;
     my @line=split /\t/;
     my $info=fixEntities($line[4]).', '.$topics[$line[1]];
     $postings[$line[0]]=$info;
     $messages[$line[2]]=$info;
     $imagesets[$line[3]]=$info if $line[3] ne '';
     }
close IN;
}

sub initUsers
{
open IN,"$directory/users";
while(<IN>)
     {
     chomp;
     my @line=split /\t/;
     $users[$line[0]]=$line[1];
     }
close IN;
}

sub getInitSub
{
return 'init'.ucfirst(lc $report);
}

sub init
{
initTopics();
initPostings();
initUsers();
die "report: unknown report type\n" if !defined(&{getInitSub()});
&{getInitSub()}();
}

sub initDomains
{
}

sub initPopularity
{
}

sub initRaw
{
}

sub initTraps
{
}

sub initVisits
{
$counter=new Counter;
}

@Months=('Jan','Feb','Mar','Apr','May','Jun',
         'Jul','Aug','Sep','Oct','Nov','Dec');

sub getTimeStr
{
my ($time)=@_;

my ($sec,$min,$hour,$day,$month)=localtime($time);
return sprintf("%3s %2i %02i:%02i:%02i",$Months[$month],$day,$hour,$min,$sec);
}

sub getAddress
{
my ($ip)=@_;

for($i=3;$i>=0;$i--)
   {
   $ip[$i]=$ip%256;
   $ip/=256;
   }
return join '.',@ip;
}

sub specify
{
my ($s)=@_;

my $c='';
my @specs=$s=~/\w+\(-?\d+\)/g;
foreach(@specs)
       {
       my ($name,$value)=/^(\w+)\((-?\d+)\)$/;
       $c.=' '.$topics[$value] if $name eq 'topic' && $value>0;
       $c.=' Все темы' if $name eq 'topic' && $value<=0;
       $c.=' '.$users[$value] if $name eq 'user';
       $c.=' '.$postings[$value] if $name eq 'post';
       $c.=' '.$messages[$value] if $name eq 'msg';
       $c.=' '.$imagesets[$value] if $name eq 'imageset';
       $c.=" N$value" if $name eq 'issue';
       }
return $c;
}

sub comment
{
my ($s)=@_;

my $c=specify($s);
$s.=" /*$c */" if $c!~/^\s*$/;
return $s;
}

sub describe
{
my ($s)=@_;

my ($type)=$s=~/^(\w+):/;
my $c='';
$c='[Статья]' if $type eq 'article';
$c='[Чат]' if $type eq 'chat';
$c='[Обсуждение]' if $type eq 'forum';
$c='[Обсуждения]' if $type eq 'forumcatalog';
$c='[Галерея]' if $type eq 'gallery';
$c='[Картинка]' if $type eq 'imageview';
$c='[Главная]' if $type eq 'index';
$c='[Площадка]' if $type eq 'kaitana';
$c='[Ссылка]' if $type eq 'link';
$c='[Сообщение]' if $type eq 'posting';
$c='[Таглит]' if $type eq 'taglit';
$c='[Мигдаль Times]' if $type eq 'times';
$c='[О пользователе]' if $type eq 'userinfo';
$c='[Голосование]' if $type eq 'vote';
$c='[Ссылки]' if $type eq 'links';
$c='[Книга]' if $type eq 'book';
$c='[Глава книги]' if $type eq 'chapter';
$c='[Обзор]' if $type eq 'review';
return $c.specify($s);
}

sub getRunSub
{
return 'run'.ucfirst(lc $report);
}

sub run
{
die "report: unknown report type\n" if !defined(&{getRunSub()});
open IN,"$directory/log";
while(<IN>)
     {
     chomp;
     my @log=split /\t/;
     next if $log[1]<$fromDate || $toDate!=0 && $log[1]>=$toDate;
     &{getRunSub()}(\@log);
     }
close IN;
}

sub runDomains
{
my ($log)=@_;

return if $$log[0] ne 'enter';
my ($domain)=$$log[3]=~/domain=(\w+)/;
$counters{$domain}=new Counter() unless defined $counters{$domain};
$counters{$domain}->inc($$log[2],$$log[1]);
}

sub runPopularity
{
my ($log)=@_;

return if $$log[0] eq 'trap' || $$log[0] eq 'enter' || $$log[0] eq 'login'
          || $$log[0] eq 'logout';
my $s=$$log[0].': '.$$log[3];
$counters{$s}=new Counter() unless defined $counters{$s};
$counters{$s}->inc($$log[2],$$log[1]);
}

sub runRaw
{
my ($log)=@_;

print getTimeStr($$log[1]).' '.getAddress($$log[2])."\t".$$log[0].': '.
      comment($$log[3])."\n";
}

sub runTraps
{
my ($log)=@_;

return if $$log[0] ne 'trap';
my $type=$$log[3];
$type=~s/\s+\[[^\]]*\]$//;
$counters{$type}=new Counter() unless defined $counters{$type};
$counters{$type}->inc($$log[2],$$log[1]);
}

sub runVisits
{
my ($log)=@_;

$counter->inc($$log[2],$$log[1]);
}

sub getDoneSub
{
return 'done'.ucfirst(lc $report);
}

sub done
{
die "report: unknown report type\n" if !defined(&{getDoneSub()});
&{getDoneSub()}();
}

sub doneDomains
{
@domains=sort {$counters{$b}->getValue() <=> $counters{$a}->getValue()}
              keys %counters;
for my $domain(@domains)
    {
    printf "%5i  %s\n",$counters{$domain}->getValue(),$domain;
    }
}

sub donePopularity
{
@pages=sort {$counters{$b}->getValue() <=> $counters{$a}->getValue()}
            keys %counters;
for my $page(@pages)
    {
    if($counters{$page}->getValue()>=$popularity)
      {
      unless($verbose)
            {
            printf "%5i  %s\n",$counters{$page}->getValue(),describe($page);
	    }
      else
            {
            printf "%5i  %s (%s)\n",$counters{$page}->getValue(),
	                            describe($page),$page;
	    }
      }
    }
}

sub doneRaw
{
}

sub doneTraps
{
@traps=sort {$counters{$b}->getValue() <=> $counters{$a}->getValue()}
            keys %counters;
for my $trap(@traps)
    {
    printf "%5i  %s\n",$counters{$trap}->getValue(),$trap;
    }
}

sub doneVisits
{
print $counter->getValue(),"\n";
}

GetOptions('directory|d=s'  => \$directory,
           'from|f=s'       => \&fromDate,
           'help|h|?'	    => \&help,
	   'interval|i=i'   => \$interval,
	   'popularity|p=i' => \$popularity,
	   'report|r=s'     => \$report,
           'to|t=s'         => \&toDate,
	   'version|v'	    => \&version,
	   'verbose|V'	    => \$verbose);

init();
run();
done();
