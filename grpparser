#!/usr/bin/perl

# @(#) $Id$

use Getopt::Long;
Getopt::Long::Configure('no_auto_abbrev','no_ignore_case','bundling');

$VERSION='0.3';

$constFileName='';
$classFileName='';
$constPrefix='';
$parentClass='';
$maskValues=0;
$grpField='';
$arrayPrefix='';

package Token;

sub new
{
my ($class,$name,$value)=@_;

return bless {'name' => $name,'value' => $value},$class;
}

sub getName
{
my ($self)=@_;

return $self->{'name'};
}

sub getValue
{
my ($self)=@_;

return $self->{'value'};
}

package Input;

sub new
{
my ($class)=@_;

my $self=bless {'line'    => 0,
                'token'   => undef,
		'current' => '',
		'comment' => 0},$class;
$self->next();
return $self;
}

sub roll
{
my ($self)=@_;

while($self->{'current'}=~/^\s*$/)
     {
     my $current=<>;
     $self->{'line'}++;
     $current='',last if !defined($current);
     chomp $current;
     $current=~s/#.*$//;
     $current=~s/\/\/.*$//;
     $current=~s/\/\*.*\*\///;
     if($self->{'comment'}!=0)
       {
       if($current=~/\*\//)
         {
         $current=~s/^.*\*\///,$self->{'comment'}=0;
	 }
       else
         {
	 $current='';
	 }
       $current=~s/\/\*.*$//,$self->{'comment'}=1 if $current=~/\/\*/;
       }
     else
       {
       $current=~s/\/\*.*$//,$self->{'comment'}=1 if $current=~/\/\*/;
       }
     $self->{'current'}=$current;
     }
return $self->{'current'};
}

%Tokens=('ident'  => '[A-Za-z_]\w*',
         'number' => '-?\d+',
         'symbol' => '[:;={}]',
	 'string' => '"(?:[^"\\\\]|\\\\.)*"|\'(?:[^\'\\\\]|\\\\.)*\'');

sub next
{
my ($self)=@_;
my $current=$self->roll();
my $token;
if($current eq '')
  {
  $token=new Token('eof','');
  }
else
  {
  keys(%Tokens);
  while(my ($name,$pattern)=each(%Tokens))
       {
       if($current=~/^\s*($pattern)(.*)$/)
         {
         $token=new Token($name,$1);
         $current=$2;
         last;
	 }
       }
  ::error("unknown token here: '$current'") unless defined($token);
  }
$self->{'current'}=$current;
$self->{'token'}=$token;
return $token;
}

sub getLine
{
my ($self)=@_;

return $self->{'line'};
}

sub getToken
{
my ($self)=@_;

return $self->{'token'};
}

package Class;

sub new
{
my ($class,$name)=@_;

$::FlagValue=$::maskValues ? $::FlagValue*2 : $::FlagValue+1;
return bless {'name'      => $name,
              'flag'      => uc $name,
	      'flagValue' => $::maskValues ? $::FlagValue/2 : $::FlagValue-1,
	      'params'    => {}},$class;
}

sub getName
{
my ($self)=@_;

return $self->{'name'};
}

sub getFlag
{
my ($self)=@_;

return $self->{'flag'};
}

sub setFlag
{
my ($self,$value)=@_;

$self->{'flag'}=$value;
}

sub getFlagValue
{
my ($self)=@_;

return $self->{'flagValue'};
}

sub getParams
{
my ($self)=@_;

return $self->{'params'};
}

sub addParam
{
my ($self,$name,$value)=@_;

$self->{'params'}->{$name}=$value;
}

package main;

@Classes=();
$FlagValue=1;
%Groups=();

sub display
{
print STDERR @_;
}

sub error
{
my ($msg)=@_;

display 'grpparser: '.$Input->getLine().": $msg\n";
exit(1);
}

sub help
{
print <<EOF;
Usage: $0 [<options>] [<file>]

Migdal website kernel GRP definition language preprocessor

  -a, --array-prefix=<prefix>  Prefix of array of class names
  -C, --const-file=<name>      File to output constants
  -f, --field=<name>           Field to store type value in
  -h, --help                   Print this help and exit
  -i, --inherit=<name>         Parent class to inherit from
  -L, --class-file=<name>      File to output classes
  -m, --mask                   Assign values for bitmask (powers of 2)
  -p, --const-prefix=<prefix>  Constant prefix
  -v, --version                Print version information and exit

Report bugs to <balu\@migdal.ru>
EOF
exit;
}

sub version
{
print <<EOF;
grpparser (migdal $VERSION)
Copyright (C) 2002 by Dmitry E. Melamud.

This program is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public
License (see LICENSE).

EOF
exit;
}

sub init
{
$|=1;
GetOptions('array-prefix|a=s' => \$arrayPrefix,
           'const-file|C=s'   => \$constFileName,
	   'field|f=s'        => \$grpField,
           'help|h|?'	      => \&help,
	   'inherit|i=s'      => \$parentClass,
	   'class-file|L=s'   => \$classFileName,
	   'mask|m'           => \$maskValues,
	   'const-prefix|p=s' => \$constPrefix,
           'version|v'	      => \&version);
$Input=new Input;
}

sub defineFlag
{
my ($class)=@_;

error('identifier expected') if $Input->getToken()->getName() ne 'ident';
$class->setFlag($Input->getToken()->getValue());
$Input->next();
error("';' expected") if $Input->getToken()->getValue() ne ';';
$Input->next();
}

sub defineGroups
{
my ($class)=@_;

while($Input->getToken()->getName() eq 'ident')
     {
     $Groups{$Input->getToken()->getValue()}|=$class->getFlagValue();
     $Input->next();
     }
error("';' expected") if $Input->getToken()->getValue() ne ';';
$Input->next();
}

sub defineAttrs
{
my ($class)=@_;

error("'}' or identifier expected") if $Input->getToken()->getName() ne 'ident';
my $ident=$Input->getToken()->getValue();
$Input->next();
if($Input->getToken()->getValue() eq ':')
  {
  $Input->next();
  defineFlag($class),return if $ident eq 'flag';
  if($ident eq 'groups')
    {
    error('groups are allowed for bitmasks only') unless $maskValues;
    defineGroups($class);
    return;
    }
  error("unknown attribute '$ident'");
  }
elsif($Input->getToken()->getValue() eq '=')
  {
  $Input->next();
  my $name=$Input->getToken()->getName();
  error('value expected') unless $name eq 'ident' or $name eq 'number' or
                                 $name eq 'string';
  $class->addParam($ident,$Input->getToken()->getValue());
  $Input->next();
  error("';' expected") if $Input->getToken()->getValue() ne ';';
  $Input->next();
  }
else
  {
  error("':' or '=' expected");
  }
}

sub defineClass
{
my $class=new Class($Input->getToken()->getValue());
push @Classes,$class;
$Input->next();
$Input->next(),return if $Input->getToken()->getValue() eq ';';
if($Input->getToken()->getValue() eq '{')
  {
  $Input->next();
  defineAttrs($class) while($Input->getToken()->getValue() ne '}');
  $Input->next();
  }
else
  {
  error("';' expected");
  }
}

sub run
{
while($Input->getToken()->getName() ne 'eof')
     {
     if($Input->getToken()->getName() eq 'ident')
       {
       if($Input->getToken()->getValue() ne 'reserved')
	 {
         defineClass();
	 }
       else
         {
	 $FlagValue=$maskValues ? $FlagValue*2 : $FlagValue+1;
	 $Input->next();
	 error("';' expected") if $Input->getToken()->getValue() ne ';';
	 $Input->next();
	 }
       }
     else
       {
       error('class name expected');
       }
     }
}

sub printConstant
{
my ($class)=@_;

my $flag=$maskValues ? sprintf('0x%x',$class->getFlagValue())
                     : $class->getFlagValue();
print GRPS "define('$constPrefix".$class->getFlag()."',$flag);\n";
if($maskValues)
  {
  my $notValue=sprintf('0x%x',$FlagValue-$class->getFlagValue()-1);
  print(GRPS "define('${constPrefix}NOT_".$class->getFlag()."',$notValue);\n");
  }
}

sub printParam
{
my ($name,$value)=@_;

print POSTINGS "function $name()\n";
print POSTINGS "{\n";
print POSTINGS "return $value;\n";
print POSTINGS "}\n";
print POSTINGS "\n";
}

sub printClass
{
my ($class)=@_;

print POSTINGS 'class '.$class->getName()."\n";
print POSTINGS "      extends $parentClass\n";
print POSTINGS "{\n";
print POSTINGS "\n";
print POSTINGS 'function '.$class->getName()."(\$row)\n";
print POSTINGS "{\n";
print POSTINGS "\$this->$parentClass(\$row);\n";
print POSTINGS "\$this->$grpField=$constPrefix".$class->getFlag().";\n";
print POSTINGS "}\n";
print POSTINGS "\n";
while(my ($name,$value)=each(%{$class->getParams()}))
   {
   printParam($name,$value);
   }
print POSTINGS "}\n";
print POSTINGS "\n";
}

sub printClassName
{
my ($class)=@_;

print GRPS " $constPrefix".$class->getFlag()." => '".$class->getName()."',\n";
}

sub done
{
open GRPS,">$constFileName";
open POSTINGS,">$classFileName";
print GRPS "<?php\n";
print GRPS "define('${constPrefix}NONE',0);\n";
print POSTINGS "<?php\n";
for(@Classes)
   {
   printConstant($_);
   printClass($_);
   }
while(my ($name,$value)=each(%Groups))
     {
     $value=$maskValues ? sprintf('0x%x',$value) : $value;
     print GRPS "define('$constPrefix$name',$value);\n";
     }
my $all=$maskValues ? sprintf('0x%x',$FlagValue-1) : $FlagValue-1;
my $name=$maskValues ? 'ALL' : 'MAX';
print GRPS "define('$constPrefix$name',$all);\n";
print GRPS "\n";
print GRPS "\$${arrayPrefix}ClassNames=array(\n";
for(@Classes)
   {
   printClassName($_);
   }
print GRPS " ${constPrefix}NONE => '$parentClass'\n";
print GRPS ");\n";
print GRPS "?>\n";
print POSTINGS "?>\n";
close GRPS;
close POSTINGS;
}

init;
run;
done;
