#!/usr/bin/perl

# @(#) $Id$

use Getopt::Long;
Getopt::Long::Configure('no_auto_abbrev','no_ignore_case','bundling');

$VERSION='0.3';

$constFileName='';
$classFileName='';
$constPrefix='';
$maskValues=0;
$grpField='';
$arrayPrefix='';

package Token;

sub new
{
my ($class,$name,$value)=@_;

return bless {'name' => $name,'value' => $value},$class;
}

sub getName
{
my ($self)=@_;

return $self->{'name'};
}

sub getValue
{
my ($self)=@_;

return $self->{'value'};
}

package Input;

sub new
{
my ($class)=@_;

my $self=bless {'line'    => 0,
                'token'   => undef,
		'current' => '',
		'comment' => 0},$class;
$self->next();
return $self;
}

sub roll
{
my ($self)=@_;

while($self->{'current'}=~/^\s*$/)
     {
     my $current=<>;
     $self->{'line'}++;
     $current='',last if !defined($current);
     chomp $current;
     $current=~s/^#.*$//;
     $current=~s/\/\/.*$//;
     $current=~s/\/\*.*\*\///;
     if($self->{'comment'}!=0)
       {
       if($current=~/\*\//)
         {
         $current=~s/^.*\*\///,$self->{'comment'}=0;
	 }
       else
         {
	 $current='';
	 }
       $current=~s/\/\*.*$//,$self->{'comment'}=1 if $current=~/\/\*/;
       }
     else
       {
       $current=~s/\/\*.*$//,$self->{'comment'}=1 if $current=~/\/\*/;
       }
     $self->{'current'}=$current;
     }
return $self->{'current'};
}

%Tokens=('ident'  => '[A-Za-z_]\w*',
         'number' => '-?(?:0x[\dA-Fa-f]+|\d+)',
         'symbol' => '[:;={}]',
	 'string' => '"(?:[^"\\\\]|\\\\.)*"|\'(?:[^\'\\\\]|\\\\.)*\'');

sub next
{
my ($self)=@_;
my $current=$self->roll();
my $token;
if($current eq '')
  {
  $token=new Token('eof','');
  }
else
  {
  keys(%Tokens);
  while(my ($name,$pattern)=each(%Tokens))
       {
       if($current=~/^\s*($pattern)(.*)$/)
         {
         $token=new Token($name,$1);
         $current=$2;
         last;
	 }
       }
  ::error("unknown token here: '$current'") unless defined($token);
  }
$self->{'current'}=$current;
$self->{'token'}=$token;
return $token;
}

sub getLine
{
my ($self)=@_;

return $self->{'line'};
}

sub getToken
{
my ($self)=@_;

return $self->{'token'};
}

package Class;

sub new
{
my ($class,$name)=@_;

my $value=$::FlagValue;
$::FlagValue=$::maskValues ? $::FlagValue*2 : $::FlagValue+1;
return bless {'name'      => $name,
	      'flag'      => uc $name,
	      'flagValue' => $value,
	      'params'    => {}},$class;
}

sub getName
{
my ($self)=@_;

return $self->{'name'};
}

sub getFlag
{
my ($self)=@_;

return $self->{'flag'};
}

sub setFlag
{
my ($self,$value)=@_;

$self->{'flag'}=$value;
}

sub getFlagValue
{
my ($self)=@_;

return $self->{'flagValue'};
}

sub setFlagValue
{
my ($self,$value)=@_;

$self->{'flagValue'}=$value;
}

sub getParams
{
my ($self)=@_;

return $self->{'params'};
}

sub addParam
{
my ($self,$name,$value)=@_;

$self->{'params'}->{$name}=$value;
}

package main;

@Classes=();
$defaultClass=new Class('default');
$FlagValue=1;
%Groups=();

sub display
{
print STDERR @_;
}

sub error
{
my ($msg)=@_;

display 'grpparser: '.$Input->getLine().": $msg\n";
exit(1);
}

sub help
{
print <<EOF;
Usage: $0 [<options>] [<file>]

Migdal website kernel GRP definition language preprocessor

  -a, --array-prefix=<prefix>  Prefix of arrays of property values
  -C, --const-file=<name>      File to output constants
  -f, --field=<name>           Field to store type value in
  -h, --help                   Print this help and exit
  -L, --class-file=<name>      File to output classes
  -m, --mask                   Assign values for bitmask (powers of 2)
  -p, --const-prefix=<prefix>  Constant prefix
  -v, --version                Print version information and exit

Report bugs to <balu\@migdal.ru>
EOF
exit;
}

sub version
{
print <<EOF;
grpparser (migdal $VERSION)
Copyright (C) 2002 by Dmitry E. Melamud.

This program is free software; you can redistribute it
and/or modify it under the terms of the GNU General Public
License (see LICENSE).

EOF
exit;
}

sub init
{
$|=1;
GetOptions('array-prefix|a=s' => \$arrayPrefix,
           'const-file|C=s'   => \$constFileName,
	   'field|f=s'        => \$grpField,
           'help|h|?'	      => \&help,
	   'class-file|L=s'   => \$classFileName,
	   'mask|m'           => \$maskValues,
	   'const-prefix|p=s' => \$constPrefix,
           'version|v'	      => \&version);
$Input=new Input;
}

sub defineFlag
{
my ($class)=@_;

error('identifier expected') if $Input->getToken()->getName() ne 'ident';
$class->setFlag($Input->getToken()->getValue());
$Input->next();
error("';' expected") if $Input->getToken()->getValue() ne ';';
$Input->next();
}

sub defineGroups
{
my ($class)=@_;

while($Input->getToken()->getName() eq 'ident')
     {
     my $name=$Input->getToken()->getValue();
     if($maskValues)
       {
       $Groups{$name}|=$class->getFlagValue();
       }
     else
       {
       $Groups{$name}=[] unless exists $Groups{$name};
       push @{$Groups{$name}},$class->getFlagValue();
       }
     $Input->next();
     }
error("';' expected") if $Input->getToken()->getValue() ne ';';
$Input->next();
}

sub copyItem
{
my($ident,$items)=@_;

$item={};
for my $i(@$items)
   {
   next unless $$i{'ident'} eq "'$ident'";
   while(my ($key,$value)=each(%$i))
        {
	$$item{$key}=$value;
	}
   last;
   }
return $item;
}

sub getArrayValue
{
my ($default)=@_;

$Input->next();
my $items=[];
while($Input->getToken()->getValue() ne '}')
     {
     error('identifier expected') if $Input->getToken()->getName() ne 'ident';
     my $ident=$Input->getToken()->getValue();
     my $item=copyItem($ident,$default);
     $$item{'ident'}="'$ident'";
     $Input->next();
     if($Input->getToken()->getValue() eq '{')
       {
       $Input->next();
       while($Input->getToken()->getValue() ne '}')
            {
	    error("'}' or identifier expected")
	                           if $Input->getToken()->getName() ne 'ident';
	    my $ident=$Input->getToken()->getValue();
	    $Input->next();
	    error("'=' expected") if $Input->getToken()->getValue() ne '=';
	    $Input->next();
	    my $name=$Input->getToken()->getName();
	    error('value expected') unless $name eq 'ident' or $name eq 'number' or
					   $name eq 'string';
	    my $value=$Input->getToken()->getValue();
	    $Input->next();
	    error("';' expected") if $Input->getToken()->getValue() ne ';';
	    $Input->next();
	    $$item{$ident}=$value;
	    }
       $Input->next();
       }
     push @$items,$item;
     }
$Input->next();
return $items;
}

sub defineAttrs
{
my ($class)=@_;

error("'}' or identifier expected") if $Input->getToken()->getName() ne 'ident';
my $ident=$Input->getToken()->getValue();
$Input->next();
if($Input->getToken()->getValue() eq ':')
  {
  $Input->next();
  defineFlag($class),return if $ident eq 'flag';
  if($ident eq 'groups')
    {
    defineGroups($class);
    return;
    }
  error("unknown attribute '$ident'");
  }
elsif($Input->getToken()->getValue() eq '=')
  {
  $Input->next();
  my $value;
  if($Input->getToken()->getValue() eq '{')
    {
    $value=getArrayValue($class->getParams()->{$ident});
    }
  else
    {
    my $name=$Input->getToken()->getName();
    error('value expected') unless $name eq 'ident' or $name eq 'number' or
				   $name eq 'string';
    $value=$Input->getToken()->getValue();
    $Input->next();
    error("';' expected") if $Input->getToken()->getValue() ne ';';
    $Input->next();
    }
  $class->addParam($ident,$value);
  }
else
  {
  error("':' or '=' expected");
  }
}

sub defineClass
{
my $class;
if($Input->getToken()->getValue() ne 'default')
  {
  $class=new Class($Input->getToken()->getValue());
  while(my($name,$value)=each(%{$defaultClass->getParams()}))
       {
       $class->addParam($name,$value);
       }
  push @Classes,$class;
  }
else
  {
  $class=$defaultClass;
  }
$Input->next();
$Input->next(),return if $Input->getToken()->getValue() eq ';';
if($Input->getToken()->getValue() eq '=')
  {
  $Input->next();
  error('flag value expected') if $Input->getToken()->getName() ne 'number';
  my $value=$Input->getToken()->getValue();
  $class->setFlagValue($value);
  $FlagValue=$maskValues ? $value*2 : $value+1;
  $Input->next();
  }
if($Input->getToken()->getValue() eq '{')
  {
  $Input->next();
  defineAttrs($class) while($Input->getToken()->getValue() ne '}');
  $Input->next();
  }
else
  {
  error("';' expected");
  }
}

sub run
{
while($Input->getToken()->getName() ne 'eof')
     {
     if($Input->getToken()->getName() eq 'ident')
       {
       if($Input->getToken()->getValue() ne 'reserved')
	 {
         defineClass();
	 }
       else
         {
	 $FlagValue=$maskValues ? $FlagValue*2 : $FlagValue+1;
	 $Input->next();
	 error("';' expected") if $Input->getToken()->getValue() ne ';';
	 $Input->next();
	 }
       }
     else
       {
       error('class name expected');
       }
     }
}

sub printConstant
{
my ($class)=@_;

my $flag=$maskValues ? sprintf('0x%x',$class->getFlagValue())
                     : $class->getFlagValue();
print GRPS "const $constPrefix".$class->getFlag()." = $flag;\n";
if($maskValues)
  {
  my $notValue=sprintf('0x%x',$FlagValue-$class->getFlagValue()-1);
  print(GRPS "const ${constPrefix}NOT_".$class->getFlag()." = $notValue;\n");
  }
}

sub printScalarParam
{
my ($name)=@_;

print POSTINGS "private \$$name;\n";
print POSTINGS "\n";
print POSTINGS "public function get$name() {\n";
print POSTINGS "    return \$this->$name;\n";
print POSTINGS "}\n";
print POSTINGS "\n";
print POSTINGS "public function set$name(\$$name) {\n";
print POSTINGS "    \$this->$name = \$$name;\n";
print POSTINGS "}\n";
print POSTINGS "\n";
}

sub printArrayParam
{
my ($name)=@_;

printScalarParam($name);
}

sub printConstParam
{
my ($name)=@_;

my $Name=ucfirst $name;
my $composite=0;
print GRPS "\$$arrayPrefix$Name=array(\n";
for(@Classes)
   {
   my $flag=$constPrefix.$_->getFlag();
   my $value=${$_->getParams()}{$name};
   if(ref($value) eq 'ARRAY')
     {
     $out="array(\n";
     for my $item(@$value)
         {
         $out.="        array(\n";
	 while(my ($key,$val)=each(%$item))
	      {
	      $out.="            '$key' => $val,\n";
	      }
         $out.="        ),\n";
	 }
     $out.="    )";
     $value=$out;
     }
   $composite=1 if $value=~/\$[\[{]/;
   print GRPS "    $flag => $value,\n";
   }
my $value=${$defaultClass->getParams()}{$name};
if(ref($value) eq 'ARRAY')
  {
  $out="array(\n";
  for my $item(@$value)
      {
      $out.="        array(\n";
      while(my ($key,$val)=each(%$item))
	   {
	   $out.="            '$key' => $val,\n";
	   }
      $out.="        ),\n";
      }
  $out.="    )";
  $value=$out;
  }
$composite=1 if $value=~/\$[\[{]/;
print GRPS "    ${constPrefix}NONE => $value,\n";
print GRPS ");\n";
print GRPS "\n";
print POSTINGS "public function $name() {\n";
print POSTINGS "    global \$$arrayPrefix${Name};\n";
print POSTINGS "\n";
if(!$composite)
  {
  print POSTINGS "    return \$$arrayPrefix${Name}[\$this->$grpField];\n";
  }
else
  {
  print POSTINGS "    return \$this->getCompositeValue(\$$arrayPrefix${Name}[\$this->$grpField]);\n";
  }
print POSTINGS "}\n";
print POSTINGS "\n";
}

sub printParam
{
my ($name,$value)=@_;

printScalarParam($name),return if $value eq 'var';
printArrayParam($name),return if $value eq 'array';
printConstParam($name,$value);
}

sub done
{
open GRPS,">$constFileName";
open POSTINGS,">$classFileName";
print GRPS "<?php\n";
print GRPS "const ${constPrefix}NONE = 0;\n";
for(@Classes)
   {
   printConstant($_);
   }
if($maskValues)
  {
  while(my ($name,$value)=each(%Groups))
       {
       $value=sprintf('0x%x',$value);
       print GRPS "const $constPrefix$name = $value;\n";
       }
  }
else
  {
  for my $name(keys %Groups)
      {
      print GRPS "const $constPrefix$name = $constPrefix$name;\n";
      }
  print GRPS "\$${arrayPrefix}Groups = array(\n";
  while(my ($name,$value)=each(%Groups))
       {
       $value='array('.join(',',@$value).')';
       print GRPS "    '$constPrefix$name' => $value,\n";
       }
  my $all='array('.join(',',map {$_->getFlagValue()} @Classes ).')';
  print GRPS "    '${constPrefix}ALL' => $all\n";
  print GRPS ");\n";
  print GRPS "\n";
  }
if($maskValues)
  {
  my $all=sprintf('0x%x',$FlagValue-1);
  print GRPS "const ${constPrefix}ALL = $all;\n";
  }
else
  {
  my $max=$FlagValue-1;
  print GRPS "const ${constPrefix}MAX = $max;\n";
  print GRPS "const ${constPrefix}ALL = ${constPrefix}ALL;\n";
  }
print GRPS "\n";
while(my ($name,$value)=each(%{$defaultClass->getParams()}))
     {
     printParam($name,$value);
     }
print GRPS "?>\n";
close GRPS;
close POSTINGS;
}

init;
run;
done;
